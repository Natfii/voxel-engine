================================================================================
VOXEL ENGINE CRASH INVESTIGATION SUMMARY
Breaking/Placing Blocks - Root Cause Analysis
================================================================================

EXECUTIVE SUMMARY
================================================================================

Found 5 critical issues causing crashes when breaking and placing blocks.
The PRIMARY cause is a DEADLOCK in the mutex locking system that occurs 
EVERY time a block is broken or placed.

Impact: Game freezes/crashes immediately when trying to modify blocks
Severity: CRITICAL (blocks primary gameplay feature)
Status: All issues thoroughly documented with exact line numbers


ROOT CAUSE #1: DEADLOCK (CRITICAL SEVERITY)
================================================================================

Location: /home/user/voxel-engine/src/world.cpp lines 818-928 (breakBlock)
          /home/user/voxel-engine/src/world.cpp lines 942-1011 (placeBlock)
          /home/user/voxel-engine/src/chunk.cpp lines 453-483

Problem:
--------
1. breakBlock() acquires UNIQUE lock on m_chunkMapMutex (line 821)
2. Calls affectedChunk->generateMesh(this) while holding lock (line 885)
3. generateMesh() calls world->getBlockAt() for neighboring chunks (lines 461, 477)
4. getBlockAt() tries to acquire SHARED lock on SAME m_chunkMapMutex (line 603)
5. std::shared_mutex is NOT reentrant → DEADLOCK!

When It Happens:
- EVERY block break operation
- EVERY block placement operation
- When mesh regeneration accesses neighboring chunks
- Game thread freezes indefinitely

Why std::shared_mutex Causes Deadlock:
- std::shared_mutex cannot be re-acquired by the same thread
- Trying to acquire any lock (shared or unique) on a mutex you already own
  causes deadlock or undefined behavior
- The current design violates this constraint


ROOT CAUSE #2: OUT-OF-BOUNDS REGISTRY ACCESS (HIGH SEVERITY)
================================================================================

Location: /home/user/voxel-engine/src/chunk.cpp line 493 (PRIMARY)
          Multiple other files without bounds checks

Problem:
--------
Block IDs are not validated before accessing BlockRegistry:

chunk.cpp line 493:
    int id = m_blocks[X][Y][Z];
    if (id == 0) continue;
    const BlockDefinition& def = registry.get(id);  // ← NO BOUNDS CHECK!

If blockID is negative or >= registry.count(), this throws exception.

Additional Missing Checks:
- water_simulation.cpp lines 426, 446
- world.cpp lines 827, 865, 960, 1060, 1082, 1107, 1132, 1146
- block_system.cpp lines 810, 835, 873
- inventory.cpp lines 220, 322
- targeting_system.cpp line 176

Why It Crashes:
- Corrupted block data from save file or memory write
- Uninitialized block IDs
- Invalid data in chunk arrays
- Negative block IDs


ROOT CAUSE #3: MISSING INVENTORY VALIDATION (MEDIUM SEVERITY)
================================================================================

Location: /home/user/voxel-engine/src/main.cpp lines 851-853

Problem:
--------
Block placement only validates blockID > 0, not < registry.count():

    if (selectedItem.blockID > 0) {  // Only checks > 0!
        world.placeBlock(placePosition, selectedItem.blockID, &renderer);
    }

If inventory has blockID = 999 but only 20 blocks are registered:
- placeBlock() succeeds (no validation)
- Later mesh generation crashes trying to access registry.get(999)


ROOT CAUSE #4: RACE CONDITIONS (MEDIUM-HIGH SEVERITY)
================================================================================

Location: /home/user/voxel-engine/src/chunk.cpp lines 453-483
          /home/user/voxel-engine/src/world.cpp lines 880-927

Problem:
--------
Even if deadlock is fixed, race conditions remain:

- breakBlock() gets unique lock
- Calls generateMesh() which reads neighboring chunk data
- If another thread modifies neighbor chunks concurrently, data races occur
- Mesh generation could use stale data or corrupted blocks

This requires holding a lock for the entire mesh generation operation,
not releasing it between reading neighbors and mesh creation.


ROOT CAUSE #5: MESH BUFFER POOL VECTOR SAFETY (LOW-MEDIUM SEVERITY)
================================================================================

Location: /home/user/voxel-engine/include/mesh_buffer_pool.h

Problem:
--------
If multiple chunks call generateMesh concurrently and use the buffer pool,
vector reallocations could invalidate iterators or cause memory corruption.

This is a secondary issue - becomes relevant only after fixing the deadlock.


RECOMMENDED FIX PRIORITY
================================================================================

PRIORITY 1 - CRITICAL: Fix the Deadlock
--------------------------------------
MUST fix before anything else works. Two options:

Option A: Use Unsafe Functions in generateMesh
  - Change generateMesh() to use getBlockAtUnsafe() and 
    getChunkAtWorldPosUnsafe() instead of getBlockAt()
  - Requires generateMesh() caller to already hold the lock
  - Add comments documenting lock preconditions
  Files: chunk.cpp, world.cpp

Option B: Refactor Lock Management  
  - Change generateMesh() signature to accept lock context:
    void generateMesh(World* world, std::shared_lock<std::shared_mutex>& lock)
  - Or use a different synchronization approach
  - More complex but cleaner API

Estimated Implementation Time: 2-4 hours
Estimated Testing Time: 1-2 hours


PRIORITY 2 - HIGH: Add Bounds Checking
----------------------------------
Add validation before every registry.get() call:

    if (blockID < 0 || blockID >= registry.count()) {
        Logger::warning() << "Invalid block ID: " << blockID;
        // Handle appropriately (skip block, default to stone, etc.)
    }

Files to Fix:
  - /home/user/voxel-engine/src/chunk.cpp line 493
  - /home/user/voxel-engine/src/water_simulation.cpp lines 426, 446
  - /home/user/voxel-engine/src/world.cpp lines 827, 865, 960, 1060, 1082, 1107, 1132, 1146
  - /home/user/voxel-engine/src/block_system.cpp lines 810, 835, 873
  - /home/user/voxel-engine/src/inventory.cpp lines 220, 322
  - /home/user/voxel-engine/src/targeting_system.cpp line 176

Estimated Implementation Time: 1-2 hours
Estimated Testing Time: 30 minutes


PRIORITY 3 - HIGH: Validate Inventory Block IDs
---------------------------------------------
Update main.cpp lines 851-853:

    if (selectedItem.blockID > 0 && selectedItem.blockID < registry.count()) {
        glm::vec3 placePosition = target.blockPosition + target.hitNormal;
        world.placeBlock(placePosition, selectedItem.blockID, &renderer);
    }

Estimated Implementation Time: 15 minutes
Estimated Testing Time: 15 minutes


PRIORITY 4 - MEDIUM: Improve Lock Management
------------------------------------------
After fixing deadlock, review and test concurrent block modifications:

- Ensure lock is held for entire break/place operation including mesh gen
- Consider using scoped_lock for exception safety
- Add stress tests for rapid block breaking/placing
- Test with multiple player clients (if multiplayer)

Estimated Implementation Time: 2-4 hours
Estimated Testing Time: 2-3 hours


PRIORITY 5 - MEDIUM: Mesh Buffer Pool Thread Safety
-------------------------------------------------
After all other fixes, audit mesh_buffer_pool.h for concurrent access safety:

- Verify no concurrent vector reallocations
- Add mutex protection if needed
- Test concurrent mesh generation

Estimated Implementation Time: 1-2 hours
Estimated Testing Time: 1-2 hours


TESTING RECOMMENDATIONS
================================================================================

After Each Fix:
1. Test single block breaking
2. Test single block placement
3. Test rapid repeated breaking (10+ blocks/second)
4. Test rapid repeated placement (10+ blocks/second)
5. Test breaking/placing at chunk boundaries
6. Test breaking/placing on neighbor chunks
7. Monitor for deadlocks (timeout if > 5 seconds between actions)

Advanced Testing:
1. Stress test: Break 1000 blocks in sequence
2. Stress test: Place 1000 blocks in sequence
3. Check for memory leaks during long operations
4. Verify mesh integrity after modifications
5. Test with corrupted save files (invalid block IDs)
6. Concurrent operations (if multiplayer)


FILES TO MODIFY
================================================================================

High Priority (Must Fix):
  1. /home/user/voxel-engine/src/world.cpp - Fix deadlock (Priority 1)
  2. /home/user/voxel-engine/src/chunk.cpp - Add bounds checks (Priority 2)
  3. /home/user/voxel-engine/src/main.cpp - Validate inventory IDs (Priority 3)

Medium Priority (Should Fix):
  4. /home/user/voxel-engine/src/water_simulation.cpp - Add bounds checks (Priority 2)
  5. /home/user/voxel-engine/src/block_system.cpp - Add bounds checks (Priority 2)
  6. /home/user/voxel-engine/src/inventory.cpp - Add bounds checks (Priority 2)
  7. /home/user/voxel-engine/src/targeting_system.cpp - Add bounds checks (Priority 2)


DETAILED ANALYSIS DOCUMENTS
================================================================================

Two additional detailed documents have been created:

1. /tmp/crash_analysis.md
   - Comprehensive issue descriptions
   - Problem analysis
   - Recommended fixes with code examples

2. /tmp/detailed_crash_locations.md
   - Exact file paths and line numbers
   - Code snippets showing problematic sections
   - Detailed deadlock flow diagram
   - Race condition scenarios


CONCLUSION
================================================================================

The voxel engine crashes when breaking/placing blocks due to a critical 
deadlock in the mutex locking system. This is a high-priority bug that 
prevents the primary gameplay feature from functioning.

The root cause is attempting to acquire a lock on an already-owned 
std::shared_mutex during mesh regeneration. This must be fixed immediately.

Secondary issues with bounds checking should also be addressed to prevent
additional crashes from corrupted or invalid block IDs.

Total Estimated Fix Time: 6-10 hours (Priority 1-3 items)
Full Testing and Optimization: 5-7 hours
Total Project Duration: 12-17 hours

================================================================================
