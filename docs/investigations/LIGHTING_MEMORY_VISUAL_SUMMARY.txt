================================================================================
MEMORY USAGE VISUALIZATION - VOXEL ENGINE LIGHTING SYSTEM
================================================================================

MEMORY PER CHUNK (Per 32x32x32 = 32,768 blocks)
════════════════════════════════════════════════════════════════════════════

BlockLight (32 KB) ████ 11%
┌────────────────────────────────────────────────────────────────┐
│ Sky light (4 bits) + Block light (4 bits) = 1 byte per block   │
│ 32,768 blocks × 1 byte = 32 KB                                 │
│ STATUS: ✓ OPTIMAL                                              │
└────────────────────────────────────────────────────────────────┘

InterpolatedLight (256 KB) ████████████████████████████ 89%
┌────────────────────────────────────────────────────────────────┐
│ Sky light (float) + Block light (float) = 8 bytes per block    │
│ 32,768 blocks × 8 bytes = 262,144 bytes (256 KB)              │
│ STATUS: ⚠ EXCESSIVE (can optimize to 32 KB)                   │
└────────────────────────────────────────────────────────────────┘

TOTAL PER CHUNK: 288 KB

OPTIMIZATION OPPORTUNITY:
  BlockLight:         32 KB (required for lighting data)
  InterpolatedLight:  32 KB (if optimized from uint8_t instead of float)
  ─────────────────────────
  TOTAL OPTIMIZED:    64 KB (77% reduction from 288 KB)

════════════════════════════════════════════════════════════════════════════

TOTAL MEMORY FOR 500 LOADED CHUNKS
════════════════════════════════════════════════════════════════════════════

Current Implementation:
  BlockLight:                32 KB × 500 = 16 MB
  InterpolatedLight:         256 KB × 500 = 128 MB
  m_lightAddQueue:           8 KB (typical)
  m_lightRemoveQueue:        5 KB (typical)
  m_dirtyChunks set:         20 KB (typical)
  ─────────────────────────────────────────────────
  TOTAL LIGHTING MEMORY:     ~144 MB

After Optimization:
  BlockLight:                32 KB × 500 = 16 MB
  InterpolatedLight (opt):   32 KB × 500 = 16 MB
  m_lightAddQueue:           8 KB
  m_lightRemoveQueue:        5 KB
  m_dirtyChunks set:         20 KB
  ─────────────────────────────────────────────────
  TOTAL LIGHTING MEMORY:     ~48 MB (67% REDUCTION)

════════════════════════════════════════════════════════════════════════════

LIGHTING QUEUE GROWTH PATTERNS
════════════════════════════════════════════════════════════════════════════

NORMAL GAMEPLAY (m_lightAddQueue):
  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
  Current: ~100-500 items = 1.6-8 KB
  Status: ✓ HEALTHY

ACTIVE LIGHT PROPAGATION (m_lightAddQueue):
  ████████████████████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░
  Burst: ~1000-2000 items = 16-32 KB
  Status: ✓ ACCEPTABLE

PATHOLOGICAL CASE (m_lightAddQueue):
  ██████████████████████████████████████████████████████████████████████
  Worst case: 10,000+ items = 160+ KB
  Status: ⚠ NEEDS MONITORING (unbounded growth possible)

Same pattern for m_lightRemoveQueue (300 item/frame max vs 500 for add)

════════════════════════════════════════════════════════════════════════════

LOCAL STACK ALLOCATIONS (removeLightStep)
════════════════════════════════════════════════════════════════════════════

Stack Size Available:  ████████████████████████████████████ (2-8 MB typical)
                        1MB       2MB       3MB       4MB

Worst Case Allocation: ████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
                        0KB       226KB    

Safety Factor: 89% margin (226 KB / 2 MB = 11% of typical stack)
Status: ✓ SAFE (but monitor for stacking)

════════════════════════════════════════════════════════════════════════════

MEMORY LEAKS & CLEANUP STATUS
════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────┐
│ MEMORY LEAK ANALYSIS: ✓ NO LEAKS DETECTED                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Queue Processing:        ✓ RAII - all nodes properly dequeued     │
│  Chunk Pointers:          ✓ notifyChunkUnload() prevents dangling  │
│  Local Allocations:       ✓ Stack-based, auto cleanup on exit      │
│  Exception Safety:        ✓ No resource leaks on exceptions        │
│  Chunk Data Cleanup:      ✓ std::array auto-freed with chunk       │
│  Dirty Chunk Tracking:    ✓ Properly removed on unload             │
│                                                                     │
│  CONFIDENCE LEVEL: HIGH ████████████████████████░░░░░░░░░░░░░░░░ │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

════════════════════════════════════════════════════════════════════════════

ALLOCATION HOTSPOTS RANKED BY FREQUENCY × SIZE
════════════════════════════════════════════════════════════════════════════

1. InterpolatedLight (256 KB per chunk) ████████████████████
   Frequency: Once per chunk load
   Impact: HIGH - 128 MB for 500 chunks
   Optimization: Reduce float to uint8_t

2. m_lightAddQueue (8 KB per frame max) ██
   Frequency: Every frame during active lighting
   Impact: LOW - bounded by MAX_LIGHT_ADDS_PER_FRAME
   Risk: Unbounded growth if processing slow

3. m_lightRemoveQueue (5 KB per frame max) █
   Frequency: Every frame during active lighting
   Impact: LOW - bounded by MAX_LIGHT_REMOVES_PER_FRAME
   Risk: Unbounded growth if processing slow

4. Local deques in removeLightStep (226 KB worst) ████
   Frequency: Up to 300 times per frame
   Impact: MEDIUM - stack pressure on large removals
   Risk: Stack overflow if many large removals queued

5. getVisibleChunks() vector (1 KB max) ░
   Frequency: Once per viewport lighting recalculation
   Impact: MINIMAL - short-lived allocation
   Risk: NONE - proper cleanup

════════════════════════════════════════════════════════════════════════════

MEMORY CONSTRAINTS & DESIGN DECISIONS
════════════════════════════════════════════════════════════════════════════

CONSTRAINTS:
  - Real-time rendering: Must process lighting within 16ms (60 FPS)
  - Incremental updates: Cannot block on light propagation
  - Multiple chunks visible: ~500 chunks in memory typical

DESIGN CHOICES (GOOD):
  ✓ Bit-packed BlockLight (1 byte = 2 channels)
  ✓ Deque-based queuing (efficient FIFO)
  ✓ Frame-rate bounded processing (prevents hitches)
  ✓ Unordered_set for dirty chunks (O(1) operations)
  ✓ Proper RAII throughout (no manual memory)

DESIGN CHOICES (COULD IMPROVE):
  ⚠ Float-based InterpolatedLight (8 bytes = unnecessary precision)
  ⚠ No explicit queue size limits (unbounded growth possible)
  ⚠ Stack allocation for local deques (pressure on large removals)

════════════════════════════════════════════════════════════════════════════

KEY FINDINGS SUMMARY
════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────┐
│ RESULT: NO MEMORY LEAKS - SOLID MEMORY MANAGEMENT                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│ GOOD NEWS:                                                          │
│  ✓ No memory leaks detected in any component                       │
│  ✓ Proper chunk cleanup with notifyChunkUnload()                   │
│  ✓ Efficient bit-packing for BlockLight (32 KB/chunk)              │
│  ✓ RAII throughout - no manual memory management                   │
│  ✓ Exception-safe implementations                                  │
│                                                                     │
│ AREAS FOR IMPROVEMENT:                                              │
│  ⚠ InterpolatedLight: 256 KB/chunk (can reduce to 32 KB)           │
│     → Would save 96 MB for 500 chunks                              │
│                                                                     │
│  ⚠ Queue growth unbounded between frames                           │
│     → Add size limits and monitoring                               │
│                                                                     │
│  ⚠ Local stack deques in removeLightStep                           │
│     → 226 KB worst case (safe but concerning)                      │
│     → Monitor for large removal operations                         │
│                                                                     │
│ PRIORITY FIXES:                                                     │
│  1. Optimize InterpolatedLight (biggest bang for buck)             │
│  2. Add queue size monitoring/limits                               │
│  3. Profile actual usage patterns during gameplay                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘

════════════════════════════════════════════════════════════════════════════

FOR DETAILED ANALYSIS, SEE:
  - LIGHTING_MEMORY_ANALYSIS.md (comprehensive report with all details)
  - LIGHTING_MEMORY_SUMMARY.txt (executive summary)
  - LIGHTING_CODE_REFERENCES.txt (code locations and line numbers)

================================================================================
