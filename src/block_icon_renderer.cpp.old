#include "block_icon_renderer.h"
#include "block_system.h"
#include <algorithm>

VkDescriptorSet BlockIconRenderer::s_atlasDescriptorSet = VK_NULL_HANDLE;

void BlockIconRenderer::init(VkDescriptorSet atlasDescriptorSet) {
    s_atlasDescriptorSet = atlasDescriptorSet;
}

void BlockIconRenderer::drawBlockIcon(ImDrawList* drawList, const ImVec2& pos, float size, int blockID) {
    auto& registry = BlockRegistry::instance();
    if (blockID <= 0 || blockID >= registry.count()) {
        return;
    }

    const BlockDefinition& block = registry.get(blockID);

    // Use textured version if we have the atlas and the block has textures
    if (s_atlasDescriptorSet != VK_NULL_HANDLE && block.hasTexture) {
        drawIsometricCubeTextured(drawList, pos, size, blockID);
    } else {
        // Fallback to color version
        ImVec4 topColor = getBlockColor(blockID, 0);    // Top face
        ImVec4 leftColor = getBlockColor(blockID, 1);   // Left face
        ImVec4 rightColor = getBlockColor(blockID, 2);  // Right face
        drawIsometricCube(drawList, pos, size, topColor, leftColor, rightColor);
    }
}

void BlockIconRenderer::drawBlockPreview(ImDrawList* drawList, const ImVec2& pos, float size, int blockID) {
    // Same as icon but larger
    drawBlockIcon(drawList, pos, size, blockID);
}

ImVec4 BlockIconRenderer::getBlockColor(int blockID, int face) {
    auto& registry = BlockRegistry::instance();
    if (blockID <= 0 || blockID >= registry.count()) {
        return ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
    }

    const BlockDefinition& block = registry.get(blockID);

    // If block has a solid color, use it
    if (block.hasColor) {
        ImVec4 baseColor = ImVec4(block.color.r, block.color.g, block.color.b, 1.0f);

        // Apply shading based on face (isometric lighting)
        switch (face) {
            case 0: // Top - brightest
                return baseColor;
            case 1: // Left - medium
                return ImVec4(baseColor.x * 0.75f, baseColor.y * 0.75f, baseColor.z * 0.75f, 1.0f);
            case 2: // Right - darkest
                return ImVec4(baseColor.x * 0.55f, baseColor.y * 0.55f, baseColor.z * 0.55f, 1.0f);
        }
    }

    // For textured blocks, use a neutral gray with shading
    switch (face) {
        case 0: return ImVec4(0.8f, 0.8f, 0.8f, 1.0f);  // Top
        case 1: return ImVec4(0.6f, 0.6f, 0.6f, 1.0f);  // Left
        case 2: return ImVec4(0.45f, 0.45f, 0.45f, 1.0f); // Right
    }

    return ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
}

void BlockIconRenderer::getTextureUVs(int blockID, int face, ImVec2& uv0, ImVec2& uv1) {
    // NOTE: This function works with dynamically loaded blocks at runtime
    // Users can add new block YAML files and textures to assets/blocks/
    // and they will automatically appear with correct icons in the inventory
    auto& registry = BlockRegistry::instance();
    if (blockID <= 0 || blockID >= registry.count()) {
        uv0 = ImVec2(0, 0);
        uv1 = ImVec2(1, 1);
        return;
    }

    const BlockDefinition& block = registry.get(blockID);
    // Query atlas grid size dynamically - this adjusts based on how many blocks are loaded
    int gridSize = registry.getAtlasGridSize();
    if (gridSize == 0) gridSize = 1;

    // Get the appropriate face texture coordinates
    const BlockDefinition::FaceTexture* faceTexture = nullptr;

    if (block.useCubeMap) {
        switch (face) {
            case 0: faceTexture = &block.top; break;    // Top
            case 1: faceTexture = &block.left; break;   // Left
            case 2: faceTexture = &block.right; break;  // Right
            default: faceTexture = &block.all; break;
        }
    } else {
        faceTexture = &block.all;
    }

    // Calculate UV coordinates from atlas grid position
    float cellSize = 1.0f / gridSize;
    uv0 = ImVec2(faceTexture->atlasX * cellSize, faceTexture->atlasY * cellSize);
    uv1 = ImVec2((faceTexture->atlasX + 1) * cellSize, (faceTexture->atlasY + 1) * cellSize);
}

void BlockIconRenderer::drawIsometricCubeTextured(ImDrawList* drawList, const ImVec2& center, float size, int blockID) {
    // Isometric projection constants
    const float isoAngle = 0.5f;
    const float halfSize = size * 0.5f;

    // Calculate face vertices
    ImVec2 topFace[4] = {
        ImVec2(center.x, center.y - size * 0.35f),                    // Top point
        ImVec2(center.x + size * 0.45f, center.y - size * 0.1f),      // Right point
        ImVec2(center.x, center.y + size * 0.15f),                    // Bottom point
        ImVec2(center.x - size * 0.45f, center.y - size * 0.1f)       // Left point
    };

    ImVec2 leftFace[4] = {
        ImVec2(center.x - size * 0.45f, center.y - size * 0.1f),      // Top-left
        ImVec2(center.x, center.y + size * 0.15f),                    // Top-right
        ImVec2(center.x, center.y + size * 0.5f),                     // Bottom-right
        ImVec2(center.x - size * 0.45f, center.y + size * 0.25f)      // Bottom-left
    };

    ImVec2 rightFace[4] = {
        ImVec2(center.x + size * 0.45f, center.y - size * 0.1f),      // Top-right
        ImVec2(center.x, center.y + size * 0.15f),                    // Top-left
        ImVec2(center.x, center.y + size * 0.5f),                     // Bottom-left
        ImVec2(center.x + size * 0.45f, center.y + size * 0.25f)      // Bottom-right
    };

    // Get UV coordinates for each face
    ImVec2 uvTop0, uvTop1, uvLeft0, uvLeft1, uvRight0, uvRight1;
    getTextureUVs(blockID, 0, uvTop0, uvTop1);     // Top
    getTextureUVs(blockID, 1, uvLeft0, uvLeft1);   // Left
    getTextureUVs(blockID, 2, uvRight0, uvRight1); // Right

    ImTextureID texID = (ImTextureID)s_atlasDescriptorSet;

    // Draw faces in back-to-front order with textures
    // Right face (darkened)
    drawList->AddImageQuad(texID,
        rightFace[0], rightFace[1], rightFace[2], rightFace[3],
        ImVec2(uvRight0.x, uvRight0.y), ImVec2(uvRight1.x, uvRight0.y),
        ImVec2(uvRight1.x, uvRight1.y), ImVec2(uvRight0.x, uvRight1.y),
        IM_COL32(140, 140, 140, 255)); // Darken right face
    drawList->AddQuad(rightFace[0], rightFace[1], rightFace[2], rightFace[3],
        IM_COL32(0, 0, 0, 100), 1.0f);

    // Left face (medium shade)
    drawList->AddImageQuad(texID,
        leftFace[0], leftFace[1], leftFace[2], leftFace[3],
        ImVec2(uvLeft0.x, uvLeft0.y), ImVec2(uvLeft1.x, uvLeft0.y),
        ImVec2(uvLeft1.x, uvLeft1.y), ImVec2(uvLeft0.x, uvLeft1.y),
        IM_COL32(190, 190, 190, 255)); // Medium shade left face
    drawList->AddQuad(leftFace[0], leftFace[1], leftFace[2], leftFace[3],
        IM_COL32(0, 0, 0, 100), 1.0f);

    // Top face (brightest)
    drawList->AddImageQuad(texID,
        topFace[0], topFace[1], topFace[2], topFace[3],
        ImVec2(uvTop0.x, uvTop0.y), ImVec2(uvTop1.x, uvTop0.y),
        ImVec2(uvTop1.x, uvTop1.y), ImVec2(uvTop0.x, uvTop1.y),
        IM_COL32(255, 255, 255, 255)); // Full bright top face
    drawList->AddQuad(topFace[0], topFace[1], topFace[2], topFace[3],
        IM_COL32(0, 0, 0, 120), 1.5f);
}

void BlockIconRenderer::drawIsometricCube(ImDrawList* drawList, const ImVec2& center, float size,
                                          const ImVec4& topColor, const ImVec4& leftColor, const ImVec4& rightColor) {
    // Isometric projection constants
    // Standard isometric: 30 degree angle
    const float isoAngle = 0.5f; // tan(30°) ≈ 0.577, using 0.5 for simplicity
    const float halfSize = size * 0.5f;

    // Calculate the 7 vertices of the isometric cube projection
    // Center the cube at 'center'
    ImVec2 top = ImVec2(center.x, center.y - halfSize);                           // Top vertex
    ImVec2 left = ImVec2(center.x - halfSize, center.y);                          // Left vertex
    ImVec2 right = ImVec2(center.x + halfSize, center.y);                         // Right vertex
    ImVec2 bottom = ImVec2(center.x, center.y + halfSize);                        // Bottom vertex (center of base)
    ImVec2 topLeft = ImVec2(center.x - halfSize * isoAngle, center.y - halfSize * isoAngle);
    ImVec2 topRight = ImVec2(center.x + halfSize * isoAngle, center.y - halfSize * isoAngle);
    ImVec2 bottomLeft = ImVec2(center.x - halfSize * isoAngle, center.y + halfSize * isoAngle);
    ImVec2 bottomRight = ImVec2(center.x + halfSize * isoAngle, center.y + halfSize * isoAngle);

    // Simplified isometric cube using diamonds/rhombus shapes
    // We'll draw three visible faces: top, left, right

    // Top face (brightest) - diamond shape
    ImVec2 topFace[4] = {
        ImVec2(center.x, center.y - size * 0.35f),                    // Top point
        ImVec2(center.x + size * 0.45f, center.y - size * 0.1f),      // Right point
        ImVec2(center.x, center.y + size * 0.15f),                    // Bottom point
        ImVec2(center.x - size * 0.45f, center.y - size * 0.1f)       // Left point
    };

    // Left face (medium shade)
    ImVec2 leftFace[4] = {
        ImVec2(center.x - size * 0.45f, center.y - size * 0.1f),      // Top-left
        ImVec2(center.x, center.y + size * 0.15f),                    // Top-right
        ImVec2(center.x, center.y + size * 0.5f),                     // Bottom-right
        ImVec2(center.x - size * 0.45f, center.y + size * 0.25f)      // Bottom-left
    };

    // Right face (darkest)
    ImVec2 rightFace[4] = {
        ImVec2(center.x + size * 0.45f, center.y - size * 0.1f),      // Top-right
        ImVec2(center.x, center.y + size * 0.15f),                    // Top-left
        ImVec2(center.x, center.y + size * 0.5f),                     // Bottom-left
        ImVec2(center.x + size * 0.45f, center.y + size * 0.25f)      // Bottom-right
    };

    // Draw faces in back-to-front order for proper occlusion
    // Right face (back-right)
    drawList->AddQuadFilled(rightFace[0], rightFace[1], rightFace[2], rightFace[3],
                            ImGui::ColorConvertFloat4ToU32(rightColor));
    drawList->AddQuad(rightFace[0], rightFace[1], rightFace[2], rightFace[3],
                      IM_COL32(0, 0, 0, 100), 1.0f);

    // Left face (back-left)
    drawList->AddQuadFilled(leftFace[0], leftFace[1], leftFace[2], leftFace[3],
                            ImGui::ColorConvertFloat4ToU32(leftColor));
    drawList->AddQuad(leftFace[0], leftFace[1], leftFace[2], leftFace[3],
                      IM_COL32(0, 0, 0, 100), 1.0f);

    // Top face (front)
    drawList->AddQuadFilled(topFace[0], topFace[1], topFace[2], topFace[3],
                            ImGui::ColorConvertFloat4ToU32(topColor));
    drawList->AddQuad(topFace[0], topFace[1], topFace[2], topFace[3],
                      IM_COL32(0, 0, 0, 120), 1.5f);
}
